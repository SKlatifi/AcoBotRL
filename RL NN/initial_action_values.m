
load('vectorField_RL_2019_P2.mat');
numGrid = 31;
x = linspace(0,1,numGrid);
y = linspace(0,1,numGrid);
% x = 1/(2*numGrid):1/numGrid:1;
% y = 1/(2*numGrid):1/numGrid:1;
[X,Y] = meshgrid(x,y);

target = [0.3 0.35];
gain_dist = 5;
sigma_dist = 1;

nets = struct;

for note = 1:length(mapFunc)
    note
    x_list = [];
    y_list = [];
    dx_list = [];
    dy_list = [];
    
    dx = mapFunc(note).deltaX(X,Y);
    dy = mapFunc(note).deltaY(X,Y);

    for i = 1:numGrid
        for j = 1:numGrid
            x_list = [x_list; X(i,j)];
            y_list = [y_list; Y(i,j)];
            dx_list = [dx_list; dx(i,j)];
            dy_list = [dy_list; dy(i,j)];        
        end
    end

    x_new = x_list + dx_list;
    y_new = y_list + dy_list;
    
    dp_list = [dx_list dy_list];
    dist_list = target - [x_list y_list];
%     reward_distance = vecnorm([x_new,y_new] - target,2,2);
%     reward_distance = (gain_dist/(sigma_dist*sqrt(2*pi))).*exp((-((x_new-target(1)).^2)-(y_new-target(2)).^2)/(2*sigma_dist^2));
%     reward_distance = dot(dp_list,dist_list,2);
    projection = dot(dp_list,dist_list,2)./dot(dist_list,dist_list,2) .* dist_list;
    reward_sign = sign(dot(projection,dist_list,2));
    reward_distance = reward_sign .* vecnorm(projection,2,2);
%     reward_distance = [];
%     for i = 1:length(x_list)
%         projection = (dot_product(i)/norm(dist_list(i,:))^2) * dist_list(i,:);
%         reward_distance(i,1) = sum(projection);
%     end

    % input = [x_list y_list];
    % output = dx_list;
    % net_output = myNeuralNetworkFunction(input);

    % Solve an Input-Output Fitting problem with a Neural Network
    % Script generated by NFTOOL

    inputs = [x_list y_list]';
    targets = reward_distance';

    % Create a Fitting Network
    hiddenLayerSize = 7;    
    net = fitnet(hiddenLayerSize);

    % Set up Division of Data for Training, Validation, Testing
    net.divideParam.trainRatio = 1;
    net.divideParam.valRatio = 0;
    net.divideParam.testRatio = 0;

    % Don't pop up NN window
    net.trainParam.showWindow = 0;

    % Train the Network
    [net,tr] = train(net,inputs,targets);

%     % Test the Network
%     outputs = net(inputs);
%     errors = gsubtract(outputs,targets);
%     performance = perform(net,targets,outputs);
% 
%     scatter3(x_list,y_list,reward_distance,'bo');
%     hold on;
%     scatter3(x_list,y_list,outputs,'ro');
    nets(note).net = net;
    
%     % Test the Network
%     P = [0.3; 0.3];
%     T = nets(note).net(P);
%     outputs = net(inputs);
%     errors = gsubtract(outputs,targets);
%     performance = perform(net,targets,outputs);
% 
%     scatter3(x_list,y_list,reward_distance,'bo');
%     hold on;
%     scatter3(x_list,y_list,outputs,'ro');
%     max(max(abs(outputs)))
%     hold off;
%     
%     pause;
%     clf;

%     % Make a mtrix for the real-time controller
%     for i = 1:numGrid
%         for j = 1:numGrid
%             P = [x(j); y(i)];          
%             nets(note).NetMat(i,j) = nets(note).net(P);            
%         end
%     end

end

